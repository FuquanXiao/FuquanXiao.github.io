{"meta":{"title":"傻瓜|无情","subtitle":"岁月不饶人,我亦未曾饶过岁月","description":"当一天和尚敲一天钟","author":"肖无情","url":"http://my.com","root":"/"},"pages":[{"title":"第一批","date":"2019-10-26T00:43:03.822Z","updated":"2019-10-24T16:11:22.468Z","comments":true,"path":"archives/hello-world.html","permalink":"http://my.com/archives/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"categories","date":"2019-10-29T15:44:36.000Z","updated":"2019-10-29T15:45:21.023Z","comments":true,"path":"categories/index-1.html","permalink":"http://my.com/categories/index-1.html","excerpt":"","text":""},{"title":"文章分类","date":"2019-10-26T00:32:28.000Z","updated":"2019-10-29T15:48:08.546Z","comments":true,"path":"categories/index.html","permalink":"http://my.com/categories/index.html","excerpt":"","text":""},{"title":"第一批","date":"2019-10-26T00:43:01.524Z","updated":"2019-10-24T16:11:22.468Z","comments":true,"path":"categories/hello-world.html","permalink":"http://my.com/categories/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"标签","date":"2019-10-26T00:32:28.000Z","updated":"2019-10-26T01:20:37.077Z","comments":true,"path":"tags/index.html","permalink":"http://my.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"git常用命令","slug":"git常用命令","date":"2019-11-09T08:13:28.000Z","updated":"2019-11-10T15:55:54.751Z","comments":true,"path":"2019/11/09/git常用命令/","link":"","permalink":"http://my.com/2019/11/09/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"[TOC] 1、版本库创建版本库（文件夹）mkdir lerangit```1234进入到该目录下``` $ cd learngit 查看文件路径 pwd ```12345678&gt; /Users/xfq/Desktop/learngit### 初始化版本库git init 通过`git init`命令把这个目录变成Git可以管理的仓库```$git init Initialized empty Git repository in /Users/xfq/Desktop/learngit/.git/ 放进去两个文件 添加到仓库添加某一个文件 add MyView.txt```1234添加全部文件```$git add . 注意点add 后面的 ” . “ 和add之间有一个空格 提交到仓库git commit -m \"learn git\"```123456789101112131415161718或者 ```$ git commit -m```输入详细的注释## 2、版本控制进行几次操作1、删除.swift文件 -&gt;提交2、添加一个新的txt -&gt; 提交3、修改第一个txt即MyView.txt 文件 —&gt;提交### 历史记录git log```$git log 123456789101112131415161718Date: Sat Nov 9 16:49:23 2019 +0800 modify first txtcommit 4aa751bb72b9373ce85783d9fc8b88cff3a6565cAuthor: xfq &lt;xfq@xfqdeMacBook-Pro.local&gt;Date: Sat Nov 9 16:48:46 2019 +0800 add new txtcommit 8f04464e6c46d3fbfbcd4e934599a567161f498eAuthor: xfq &lt;xfq@xfqdeMacBook-Pro.local&gt;Date: Sat Nov 9 16:47:34 2019 +0800 delete .swiftcommit dc9828ad2125b111ea4f6e010c5213f3c029c6f8Author: xfq &lt;xfq@xfqdeMacBook-Pro.local&gt;Date: Sat Nov 9 16:36:59 2019 +0800 learn git: 或者使用 输出commit id 和 描述 信息 1git log --pretty=oneline fb118149f888a957e01539bc645b6c4d656f081a modify first txt4aa751bb72b9373ce85783d9fc8b88cff3a6565c add new txt8f04464e6c46d3fbfbcd4e934599a567161f498e delete .swiftdc9828ad2125b111ea4f6e010c5213f3c029c6f8 learn git 返回版本-撤销commit 方法1 git reset –hard HEAD ^ git reset –hard HEAD ^ ( ^ 表示回到上一个版本，如果需要回退到上上个版本的话，将HEAD^改成HEAD^^, 以此类推。那如果要回退到前100个版本，这种方法肯定不方便，我们可以使用简便命令操作：git reset –hard HEAD~100 ); 方法2 ：git reset –hard 版本号 返回上一个版本 reset --hard HEAD^```12 git reset –hard HEAD^HEAD is now at 4aa751b add new txt 12345678此时文件MyView.txt已经找回了修改前的内容；- 重新回到modify first txt版本（最新版本）如果当前终端没有关闭可以往上翻找到modify first txt版本commit id 为 fb11814...； git reset –hard fb11814HEAD is now at fb11814 modify first txtxfqdeMacBook-Pro:learnGit xfq$ 123456 - 返回上上个（ delete .swift）版本 git reset –hard 8f0446HEAD is now at 8f04464 delete .swift 12345678此时addnew.txt 还没有被创建；- 想回到 modify first txt这个时候终端关了，上面的记录没有了找不到commit id git reflog8f04464 HEAD@{0}: reset: moving to 8f0446fb11814 HEAD@{1}: reset: moving to fb1184aa751b HEAD@{2}: reset: moving to HEAD^fb11814 HEAD@{3}: reset: moving to fb1184aa751b HEAD@{4}: reset: moving to 4aa7514aa751b HEAD@{5}: reset: moving to HEAD^上面的几次是来回移动的记录fb11814 HEAD@{6}: commit: modify first txt4aa751b HEAD@{7}: commit: add new txt8f04464 HEAD@{8}: commit: delete .swiftdc9828a HEAD@{9}: commit (initial): learn git 12 git reset –hard fb11814HEAD is now at fb11814 modify first txt 12345678910111213141516### 管理修改修改的文件在推送到远程之前 是在工作区，暂存区，master工作### 撤销修改1. 工作区修改了文件 没有提交到暂存区（没有执行add 操作）working tree内撤销2. 工作区修改了文件 提交到了暂存区（执行了 add操作）3. 工作区修改了文件提交到了master分支（执行了 add commit操作）1的解决办法a: 直接修改工作区的文件，就是把你的修改撤回😄b：git status 看一下状态 git statusOn branch masterChanges not staged for commit: (use “git add …” to update what will be committed) (use “git checkout – …” to discard changes in working directory) modified: AddNew.txtno changes added to commit (use “git add” and/or “git commit -a”) 123456789- git checkout -- &lt;file&gt; 丢弃工作区某一文件的修改- git checkout . 丢弃所有的修改(不包含新建的没有被add的文件，因为Untracked) ``git checkout -- AddNew.txt``2的解决办法执行git status git statusOn branch masterChanges to be committed: (use “git reset HEAD …” to unstage) modified: AddNew.txt new file: ForBackAddFile.txt modified: MyView.txt12345678`git reset HEAD `用命令`git reset HEAD `可以把所有暂存区的修改撤销掉（unstage），重新放回工作区包括新建的文件把部分文件的add 撤销 git reset HEAD … 1234567891011121314151617181920然后再 在执行git checkout -- file 或者git checkout .## 3、远程库在远程建立了远程仓库 把本地的learngit 提交到远程仓库方法一：在远程（github等）上建立仓库，把仓库clone 下来，把learngit代码拉进去，直接提交 常用，不在这次学习范畴。直接粘贴几个命令方法二：在远程（github等）上建立仓库 把learngit和远程直接建立联系- 和远程仓库建立联系 ```git remote add origin https://git.coding.net/Xiaowuqing/1111.git 推送到远程 远程仓库有README.md文件 push origin master```1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&gt; To https://git.coding.net/xxxx/learnGit.git&gt;&gt; ! [rejected] master -&gt; master (non-fast-forward)&gt;&gt; error: failed to push some refs to &apos;https://git.coding.net/xxxx/learnGit.git&apos;&gt;&gt; hint: Updates were rejected because the tip of your current branch is behind&gt;&gt; hint: its remote counterpart. Integrate the remote changes (e.g.&gt;&gt; hint: &apos;git pull ...&apos;) before pushing again.&gt;&gt; hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.&gt; 错误原因其实是我本地没有README.md这个文件，而远程仓库中有， &gt; 如何解决那？ &gt; 很简单 &gt; git pull --rebase origin master &gt; 执行这一句就行了 &gt; 执行完后会发现本地已经有了 README.md 这个文件&gt;&gt; 然后就是常规操作了 &gt; git push -u origin master 其实后面的这个常规操作我是执行的git push origin master 也成功了 **所有没有理解git push -u origin master **&gt; [由于远程库是空的，我们第一次推送`master`分支时，加上了`-u`参数，Git不但会把本地的`master`分支内容推送的远程新的`master`分支，还会把本地的`master`分支和远程的`master`分支关联起来，在以后的推送或者拉取时就可以简化命令](https://www.liaoxuefeng.com/wiki/896043488029600/898732864121440)。2. 无README.md文件```diff xfqdeMacBook-Pro:~ xfq$ cd /Users/xfq/Desktop/33 初始化 xfqdeMacBook-Pro:33 xfq$ git init Initialized empty Git repository in /Users/xfq/Desktop/33/.git/ 创建txt xfqdeMacBook-Pro:33 xfq$ vim 1.txt 和远程建立关联 xfqdeMacBook-Pro:33 xfq$ git remote add origin https://git.coding.net/Xiaowuqing/22.git 直接推动报错，因为本地文件没有提交 xfqdeMacBook-Pro:33 xfq$ git push origin mastererror: src refspec master does not match any.error: failed to push some refs to &apos;https://git.coding.net/Xiaowuqing/22.git&apos; 查看本地状态 xfqdeMacBook-Pro:33 xfq$ git status On branch master Initial commit Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) 1.txt nothing added to commit but untracked files present (use &quot;git add&quot; to track) 添加到暂存区 xfqdeMacBook-Pro:33 xfq$ git add . 提交到master xfqdeMacBook-Pro:33 xfq$ git commit -m &quot;init&quot; [master (root-commit) 04a2677] init 1 file changed, 1 insertion(+) create mode 100644 1.txt 推动到远程 xfqdeMacBook-Pro:33 xfq$ git push origin master Counting objects: 3, done. Writing objects: 100% (3/3), 211 bytes | 0 bytes/s, done. Total 3 (delta 0), reused 0 (delta 0) To https://git.coding.net/Xiaowuqing/22.git * [new branch] master -&gt; master xfqdeMacBook-Pro:33 xfq$ 4、分支管理xfq$ cdlink123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657xfqdeMacBook-Pro:~ xfq$ cd /Users/xfq/Desktop/33查看分支 *指向的就是当前分支xfqdeMacBook-Pro:33 xfq$ git branch* master创建并指向dev分支xfqdeMacBook-Pro:33 xfq$ git checkout -b devSwitched to a new branch &apos;dev&apos;查看分支xfqdeMacBook-Pro:33 xfq$ git branch* dev master 创建分支xfqdeMacBook-Pro:33 xfq$ git branch bugxfqdeMacBook-Pro:33 xfq$ git branch bug* dev master 修改当前分支xfqdeMacBook-Pro:33 xfq$ git checkout bugSwitched to branch &apos;bug&apos;xfqdeMacBook-Pro:33 xfq$ git branch* bug dev master 在bug分支提交xfqdeMacBook-Pro:33 xfq$ git add .xfqdeMacBook-Pro:33 xfq$ git commit -m &quot;modify txt and commit in bug branch&quot;[bug bc3594f] modify txt and commit in bug branch 2 files changed, 3 insertions(+) 切换分支xfqdeMacBook-Pro:33 xfq$ git checkout masterSwitched to branch &apos;master&apos;把bug分支合并到当前分支xfqdeMacBook-Pro:33 xfq$ git merge bugMerge made by the &apos;recursive&apos; strategy. 1.txt | 2 ++ 2.txt | 1 + 2 files changed, 3 insertions(+) 删除bug分支xfqdeMacBook-Pro:33 xfq$ git branch -d bugDeleted branch bug (was bc3594f).xfqdeMacBook-Pro:33 xfq$ git branch dev* masterxfqdeMacBook-Pro:33 xfq$","categories":[],"tags":[]},{"title":"git常用命令","slug":"git常用场景","date":"2019-11-09T08:13:28.000Z","updated":"2019-11-13T15:50:08.527Z","comments":true,"path":"2019/11/09/git常用场景/","link":"","permalink":"http://my.com/2019/11/09/git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"","text":"场景1、修改本地所连接的远程仓库# git添加/删除远程仓库https://blog.csdn.net/zhezhebie/article/details/78761417 说明：当前本地22文件连接的是1111远程项目 想把它改成连接到22远程项目 12345678910111213141516171819查看当前远程仓库路径xfqdeMacBook-Pro:22 xfq$ git remote -vorigin https://git.coding.net/Xiaowuqing/1111.git (fetch)origin https://git.coding.net/Xiaowuqing/1111.git (push)删除与远程仓库的关联xfqdeMacBook-Pro:22 xfq$ git remote rm origin查看当前远程仓库路径 什么也没有xfqdeMacBook-Pro:22 xfq$ git remote -v添加新的远程库的关联xfqdeMacBook-Pro:22 xfq$ git remote add origin https://git.coding.net/Xiaowuqing/22.git查看当前远程仓库路径xfqdeMacBook-Pro:22 xfq$ git remote -vorigin https://git.coding.net/Xiaowuqing/22.git (fetch)origin https://git.coding.net/Xiaowuqing/22.git (push) 场景2、提交到远程dev分支把代码提交到远程dev分支 12345678910111213141516171819202122xfqdeMacBook-Pro:33 xfq$ git add .xfqdeMacBook-Pro:33 xfq$ git commit -m &quot; modify to dev branch&quot;[dev 04d5b30] modify to dev branch 2 files changed, 2 insertions(+) 当前分支在dev 上可是远程并没有建立dev 分支xfqdeMacBook-Pro:33 xfq$ git pushfatal: The current branch dev has no upstream branch.To push the current branch and set the remote as upstream, use git push --set-upstream origin dev 使用完整的命令 创建并提交到dev 分支 xfqdeMacBook-Pro:33 xfq$ git push origin devCounting objects: 4, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (4/4), 367 bytes | 0 bytes/s, done.Total 4 (delta 0), reused 0 (delta 0)To https://git.coding.net/Xiaowuqing/22.git * [new branch] dev -&gt; dev 场景3、clone远程dev分支12345678910111213git clone https://git.coding.net/Xiaowuqing/22.git -b devCloning into &apos;22&apos;...remote: Enumerating objects: 28, done.remote: Counting objects: 100% (28/28), done.remote: Compressing objects: 100% (15/15), done.remote: Total 28 (delta 4), reused 0 (delta 0)Unpacking objects: 100% (28/28), done. 1234567git clone -b dev https://git.coding.net/Xiaowuqing/22.gitCloning into &apos;22&apos;...remote: Enumerating objects: 28, done.remote: Counting objects: 100% (28/28), done.remote: Compressing objects: 100% (15/15), done.remote: Total 28 (delta 4), reused 0 (delta 0)Unpacking objects: 100% (28/28), done. 这个时候是没有master分支的 1234567891011xfqdeMacBook-Pro:22 xfq$ git branch* devxfqdeMacBook-Pro:22 xfq$ git branch masterxfqdeMacBook-Pro:22 xfq$ git branckgit: &apos;branck&apos; is not a git command. See &apos;git --help&apos;.Did you mean this? branchxfqdeMacBook-Pro:22 xfq$ git branch* dev master 场景4、Git撤销&amp;回滚操作Git撤销&amp;回滚操作 撤销 在未进行git push前的所有操作，都是在“本地仓库”中执行的。我们暂且将“本地仓库”的代码还原操作叫做“撤销”！ 12git checkout fileNamegit checkout . 同时对多个文件执行了git add操作 12345678取消部分暂存$ git reset HEAD 1.txt取消全部暂存git reset HEAD撤销部分修改git checkout 1.txt撤销全部修改git checkout . 执行了commit 操作 写完代码后，我们一般这样 git add . //添加所有文件 git commit -m “本功能全部完成” 执行完commit后，想撤回commit，怎么办？ 123456789101112131415161718192021222324252627282930313233343536git reset --soft HEAD^这样就成功的撤销了你的commit注意，仅仅是撤回commit操作，您写的代码仍然保留。说一下个人理解：HEAD^的意思是上一个版本，也可以写成HEAD~1如果你进行了2次commit，想都撤回，可以使用HEAD~2 至于这几个参数：--mixed 意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作这个为默认参数,git reset --mixed HEAD^ 和 git reset HEAD^ 效果是一样的。 --soft 不删除工作空间改动代码，撤销commit，不撤销git add . --hard删除工作空间改动代码，撤销commit，撤销git add . 注意完成这个操作后，就恢复到了上一次的commit状态。顺便说一下，如果commit注释写错了，只是想改一下注释，只需要：git commit --amend此时会进入默认vim编辑器，修改注释完毕后保存就好了。或者git commit --amend -m&quot;说明&quot; Git Pro深入浅出（二）中的重置揭秘部分 回滚已进行git push，即已推送到“远程仓库”中。我们将已被提交到“远程仓库”的代码还原操作叫做“回滚”！注意：对远程仓库做回滚操作是有风险的，需提前做好备份和通知其他团队成员！ 准备工作如下 我修改2的代码写的有问题 撤销合并 git reflog","categories":[],"tags":[]},{"title":"Flutter 基本语法","slug":"Flutter 基本语法","date":"2019-11-05T16:05:00.890Z","updated":"2019-11-05T16:14:14.115Z","comments":true,"path":"2019/11/06/Flutter 基本语法/","link":"","permalink":"http://my.com/2019/11/06/Flutter%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"","text":"Final and const如果你以后不打算修改一个变量，使用 final 或者 const。 一个 final 变量只能赋值一次；一个 const 变量是编译时常量。 （Const 变量同时也是 final 变量。） 顶级的 final 变量或者类中的 final 变量在 第一次使用的时候初始化。 注意： 实例变量可以为 final 但是不能是 const 。 const 变量为编译时常量。 如果 const 变量在类中，请定义为 static const。 可以直接定义 const 和其值，也 可以定义一个 const 变量使用其他 const 变量的值来初始化其值。 const 关键字不仅仅只用来定义常量。 有可以用来创建不变的值， 还能定义构造函数为 const 类型的，这种类型 的构造函数创建的对象是不可改变的。任何变量都可以有一个不变的值。 12345678910111213// Note: [] creates an empty list.// const [] creates an empty, immutable list (EIA).var foo = const []; // foo is currently an EIA.final bar = const []; // bar will always be an EIA.const baz = const []; // baz is a compile-time constant EIA.// You can change the value of a non-final, non-const variable,// even if it used to have a const value.foo = [];// You can't change the value of a final or const variable.// bar = []; // Unhandled exception.// baz = []; // Unhandled exception. Built-in types(内置的类型)Dart 内置支持下面这些类型： numbers strings booleans lists (也被称之为 arrays) maps runes (用于在字符串中表示 Unicode 字符) symbols Numbers（数值）Dart 支持两种类型的数字： int 整数值，其取值通常位于 -253 和 253 之间。 double 64-bit (双精度) 浮点数，符合 IEEE 754 标准。 int 和 double 都是 num 的子类 字符串和数字之间转换的方式：123456789101112131415// String -&gt; intvar one = int.parse('1');assert(one == 1);// String -&gt; doublevar onePointOne = double.parse('1.1');assert(onePointOne == 1.1);// int -&gt; StringString oneAsString = 1.toString();assert(oneAsString == '1');// double -&gt; StringString piAsString = 3.14159.toStringAsFixed(2);assert(piAsString == '3.14'); ==操作符判断两个对象的内容是否一样。 如果两个字符串包含一样的字符编码序列， 则他们是相等的 三个单引号或者双引号也可以 创建多行字符串对象1234567var s1 = '''You can createmulti-line strings like this one.''';var s2 = \"\"\"This is also amulti-line string.\"\"\"; 有疑问？那r到底是什么通过提供一个 r 前缀可以创建一个 “原始 raw” 字符串：1var s = r\"In a raw string, even \\n isn't special.\"; 字符串字面量是编译时常量， 带有字符串插值的字符串定义，若干插值表达式引用的为编译时常量则其结果也是编译时常量","categories":[],"tags":[]},{"title":"关键字","slug":"关键字","date":"2019-11-05T15:27:50.245Z","updated":"2019-11-05T16:04:08.193Z","comments":true,"path":"2019/11/05/关键字/","link":"","permalink":"http://my.com/2019/11/05/%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"final 最终，完结器，java中可以使用final 关键字声明类、属性、方法； 声明时注意 使用final声明的类不能有子类 final 申明的方法不能被子类覆写 使用final申明的变量即为常量，常量不可以被修改 static 使用static声明的属性，则此属性被称为全局属性（静态属性） 类方法 非static申明的方法可以调用static声明的属性或方法，但是，static声明的方法不能调用非static声明的属性或方法","categories":[],"tags":[]},{"title":"Flutter语法","slug":"Flutter语法","date":"2019-11-04T14:59:41.483Z","updated":"2019-11-05T15:24:09.477Z","comments":true,"path":"2019/11/04/Flutter语法/","link":"","permalink":"http://my.com/2019/11/04/Flutter%E8%AF%AD%E6%B3%95/","excerpt":"","text":"final和constfinal和const 关键字用于声明不可变的(其实final是变量只能赋值一次)。不能修改使用final 或const 关键字声明的变量的值。 共同点 声明时类型可以省略，一旦赋值不能再重新复制 12345final String a = &apos;abc&apos;;final a = &apos;abc&apos;;const String a = &apos;abc&apos;;const a = &apos;abc&apos;; 不能和var同时使用 ![image-20191104231659210](/Users/xfq/Library/Application Support/typora-user-images/image-20191104231659210.png) 区别 区别一final 是单赋值，只能赋值一次，一旦赋值就不能再次修改 const 是声明时赋值，一经声明就不能再修改 1234final name; // 无类型注释final String nickname = &apos;Bobby&apos;; // 类型注释 Stringname = &apos;Bob&apos;; // 赋值第一次name = &apos;Alice&apos;; //错误：final变量 只能设置一次 const 是编译时常量，其值在编译时确定,必须在声明处赋值 final变量与类变量在首次访问时才执行初始化 12345678910111213final name = getName();String getName() &#123; print(&apos;getName&apos;); return &apos;bob&apos;;&#125;const String nickname = &apos;Bobby&apos;;main() &#123; print(nickname); print(name)&#125; 运行结果 123BobbygetNamebob final 变量在没有访问时，是不会自动进行赋值的。所以并没有 打印出 getName。等到访问name变量时才调用 getName() 函数进行赋值。 区别二当const用在=左边时，其作用是 *声明变量常量，它要求 *必须在声明变量时赋值，一旦赋值就不允许修改，而声明值一定要是编译时常数。 编译常量 表达式。表达式的所有值都是编译时可知的。 1234void main() &#123; const a = 1; const b = a &gt; 1 ? 2 : 1;&#125; const用在等号右边 当const用在=右边，其作用是 修饰值，它意味着对象的整个深度状态可以在编译时完全确定，并且对象将被冻结并且完全不可变。 一般用于修饰集合，它要求两点： 集合的元素必须是递归的编译时常数 12345oid main() &#123; var c = 2; //ERROR, 集合元素必须是编译时常数。 var a = const [c,2,3];&#125; 不允许对集合做任何改变。 12345void main() &#123; const a = const [1,2,3]; //ERROR, 不允许修改。 a[1] = 2;&#125; const修饰类的构造函数 当const修饰类的构造函数时，它要求该类的所有成员都必须是final的。 123456789101112class ConstObject &#123; final value; //ERROR, 必须是 final 变量。 int value2; const ConstObject(this.value); log() &#123; print(value); &#125;&#125; 创建和设置const 常量： 12const String nickname = 'Bobby';nickname = 'Alice'; // 错误：const变量不能再次赋值； const 关键字不只是用于声明常量，还可以用它来创建常量值；以及声明创建常量值的构造函数。任何变量都可以具有常量值。 例如： 123var foo = const [];foo = [1, 2, 3]; // 第一次赋值；foo = [2, 3, 4]; // 错误： const变量不能再次赋值； 如果是 final 变量就不能再次赋值： 12final bar = const [];bar = [1, 2, 3]; // 错误：final变量 只能设置一次 finalfinal的要求就是 其声明的变量在赋值之后就不再改变，它并不要求=的右边是编译时常数。 final有两种场景： 文件中的变量声明：必须在声明时赋值。 类的成员变量声明：可以在声明时赋值，也可以通过构造函数赋值语法糖ClassV({this.a})，或者初始化列表的方式赋值。 总结2.1 const 声明类成员变量时，const变量必须同时被声明为static的。 const变量，变量命名方式应使用全大写加下划线。 const变量只能在定义的时候初始化。 2.2 final final变量可以在构造函数参数列表或者初始化列表中初始化。 2.3 static 在文件中，变量不能声明为static。 2.4实例变量可以是final 不可能是const最终实例变量必须在构造函数主体开始之前初始化， 那么为什么呢？ const必须在声明的时候就初始化，那实例对象初始化也没有什么意义，final至少可以赋值一次","categories":[],"tags":[]},{"title":"android studio 常用快捷键","slug":"android studio 常用快捷键","date":"2019-11-03T09:19:12.007Z","updated":"2019-11-03T09:19:12.008Z","comments":true,"path":"2019/11/03/android studio 常用快捷键/","link":"","permalink":"http://my.com/2019/11/03/android%20studio%20%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"Android Studio常用操作 文本替换 全文文本替换 command + shift +r 文件内文本替换 command + r 一次性修改同一文件中所有搜索到的文字 command+control+g 文本查找 全文文本查找 command + shift +f 文件内文本查找 command + f 查找下一个 command + g 查找上一个 command + shift + g 代码格式整理 代码对其整理 command + option +L","categories":[],"tags":[]},{"title":"Typora 简单使用","slug":"Typora 简单使用","date":"2019-11-03T02:48:29.534Z","updated":"2019-11-03T04:06:42.415Z","comments":true,"path":"2019/11/03/Typora 简单使用/","link":"","permalink":"http://my.com/2019/11/03/Typora%20%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Typora的简单使用 mac[TOC] 标题command+ 数字（1、2….6） 下划线command+u 下划线 删除线删除线 123456 qqq 加粗command+b 斜体这里是斜体 链接command + k 引用 引用直接使用 &gt; 这里又是一个 &gt; 表格 command + option + t 代码块 code 前面三个 ``` 后面三个 其他内容查看 https://www.jianshu.com/p/092de536d948","categories":[],"tags":[]},{"title":"抓包原理","slug":"抓包原理","date":"2019-11-03T02:45:27.000Z","updated":"2019-11-03T04:12:16.553Z","comments":true,"path":"2019/11/03/抓包原理/","link":"","permalink":"http://my.com/2019/11/03/%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"context的理解","slug":"context的理解","date":"2019-11-01T15:12:18.000Z","updated":"2019-11-03T04:07:16.360Z","comments":true,"path":"2019/11/01/context的理解/","link":"","permalink":"http://my.com/2019/11/01/context%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"理解成创建widget的上下文就可以了。context实际是element，是为了阻止直接对element操作而抽象出来的一个概念","categories":[],"tags":[]},{"title":"设计模式之工厂模式","slug":"设计模式之工厂模式","date":"2019-10-29T15:32:46.000Z","updated":"2019-10-29T16:14:18.878Z","comments":false,"path":"2019/10/29/设计模式之工厂模式/","link":"","permalink":"http://my.com/2019/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"###工厂模式（Factory Pattern） 工厂模式（Factory Pattern）创建型模式，提供一种应用于创建对象的方法","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://my.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://my.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"静态变量和全局变化","slug":"静态变量和全局变化","date":"2019-10-26T11:01:37.000Z","updated":"2019-10-26T11:07:10.308Z","comments":false,"path":"2019/10/26/静态变量和全局变化/","link":"","permalink":"http://my.com/2019/10/26/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E5%8C%96/","excerpt":"","text":"#位置一 12345678位置1：NSInteger cellHeight = 100;@interface MMMMPeople : NSObject位置2：NSInteger cellHeight = 100;@end位置3：NSInteger cellHeight = 100; 位置二报错：Cannot declare variable inside @interface or @protocol```123.m中同样 （略） 位置1：NSInteger cellHeight = 100;@interface ViewController ()位置2：NSInteger cellHeight = 100;@end位置3：NSInteger cellHeight = 100; @implementation ViewController位置4：NSInteger cellHeight = 100; (void)functionA { }位置5：NSInteger cellHeight = 100; 1```位置2 报错：Cannot declare variable inside @interface or @protocol ######同一个工程中，两个不同 .m 文件中同样的全局变量不能同时存在，因为这样在编译或运行的时候，编译器分不清是哪个全局变量，所以我们千万不能同时在同一个工程中定义同样的全局变量！ 如果我就是想用另一个 .m 文件中的全局变量，那怎么处理呢？很简单，使用关键字 extern 修饰使用的全局变量就好了， 123456789extern NSInteger CellHeight;打印结果：0。因为当没有初始化的时候系统默认：零。 注：如果在MMMMPeople中初始化了数据，比如NSInteger CellHeight = 100；则打印结果就为100，但是在ViewController中就不能再次初始化！！！否则编译报错同上！！！#&apos;extern&apos; variable has an initializer#但是可以全局修改 cellHeight = 300; NSLog(@&quot;cellHeight ===== %ld&quot;,(long)cellHeight); -----&gt;300 静态全局变量同样不能在 2的位置声明 否则位置2 报错：Cannot declare variable inside @interface or @protocol extern想使用它，但还是不行的，静态全局变量只能在本文件中使用 #全局变量与全局静态变量的区别： (a）若程序由一个源文件构成时，全局变量与全局静态变量没有区别。(b)若程序由多个源文件构成时，全局变量与全局静态变量不同：全局静态变量使得该变量成为定义该变量的源文件所独享，即：全局静态变量对组成该程序的其它源文件是无效的 ,全局变量可以通过：extern。(c)具有外部链接（#import 会把变量和方法全部导入过去如果A中#import “B” B 中有static aa 那A中已经有了static aa 如果A修改aa其实修改的就是B中的aa）的静态；可以在所有源文件里调用并修改! 全局变量除了本文件，其他文件可以通过extern的方式引用；比如：在.h中声明了 且导入了头文件 在.m中声明了 且导入了头文件 (d)静态（static）不能使用 extern并存，(e)可以虽然不报错，但是违背了static 的初衷 ？static的左右就是在文件内部使用 来源 https://blog.csdn.net/mango_ios/article/details/52686892","categories":[{"name":"基础","slug":"基础","permalink":"http://my.com/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"编程基础","slug":"编程基础","permalink":"http://my.com/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}]},{"title":"第一批","slug":"hello-world","date":"2019-10-22T17:36:27.715Z","updated":"2019-10-24T16:11:22.468Z","comments":true,"path":"2019/10/23/hello-world/","link":"","permalink":"http://my.com/2019/10/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}